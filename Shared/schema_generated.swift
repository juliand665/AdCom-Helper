// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum AdComm {
public enum Saves {

public enum Gender: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case male = 0, female = 1
}

public enum GeneratorState: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case idle = 0, running = 1, complete = 2
}

public enum UnlockState: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case none = 0, locked = 1, unlocked = 2, new = 4, hidden = 8
}

public enum AwardState: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case locked = 0, unlocked = 1, claimed = 2, active = 4
}

public enum DealType: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case researcher = 0
}

public struct Resource: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsResource(bb: ByteBuffer) -> Resource { return Resource(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var qty: Double { let o = _accessor.offset(6); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public static func startResource(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(qty: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: qty, def: 0.0, at: 1) }
	public static func endResource(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Industry: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsIndustry(bb: ByteBuffer) -> Industry { return Industry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var unlocked: AdComm.Saves.UnlockState { let o = _accessor.offset(6); return o == 0 ? AdComm.Saves.UnlockState.none : AdComm.Saves.UnlockState(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.UnlockState.none }
	public var scrollPos: Float32 { let o = _accessor.offset(8); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
	public static func startIndustry(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(unlocked: AdComm.Saves.UnlockState, _ fbb: FlatBufferBuilder) { fbb.add(element: unlocked.rawValue, def: 0, at: 1) }
	public static func add(scrollPos: Float32, _ fbb: FlatBufferBuilder) { fbb.add(element: scrollPos, def: 0.0, at: 2) }
	public static func endIndustry(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Generator: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsGenerator(bb: ByteBuffer) -> Generator { return Generator(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var name: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var timeRemaining: Float32 { let o = _accessor.offset(6); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
	public var objectiveLevelClaimed: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var state: AdComm.Saves.GeneratorState { let o = _accessor.offset(10); return o == 0 ? AdComm.Saves.GeneratorState.idle : AdComm.Saves.GeneratorState(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.GeneratorState.idle }
	public var unlocked: AdComm.Saves.UnlockState { let o = _accessor.offset(12); return o == 0 ? AdComm.Saves.UnlockState.none : AdComm.Saves.UnlockState(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.UnlockState.none }
	public var objectiveLevelReached: Int32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var generatorUnlockedEver: Bool { let o = _accessor.offset(16); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public static func startGenerator(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 0)  }
	public static func add(timeRemaining: Float32, _ fbb: FlatBufferBuilder) { fbb.add(element: timeRemaining, def: 0.0, at: 1) }
	public static func add(objectiveLevelClaimed: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: objectiveLevelClaimed, def: 0, at: 2) }
	public static func add(state: AdComm.Saves.GeneratorState, _ fbb: FlatBufferBuilder) { fbb.add(element: state.rawValue, def: 0, at: 3) }
	public static func add(unlocked: AdComm.Saves.UnlockState, _ fbb: FlatBufferBuilder) { fbb.add(element: unlocked.rawValue, def: 0, at: 4) }
	public static func add(objectiveLevelReached: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: objectiveLevelReached, def: 0, at: 5) }
	public static func add(generatorUnlockedEver: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: generatorUnlockedEver, def: false, at: 6) }
	public static func endGenerator(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Mission: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsMission(bb: ByteBuffer) -> Mission { return Mission(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var state: AdComm.Saves.AwardState { let o = _accessor.offset(6); return o == 0 ? AdComm.Saves.AwardState.locked : AdComm.Saves.AwardState(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.AwardState.locked }
	public var progress: Double { let o = _accessor.offset(8); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public static func startMission(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: id, def: 0, at: 0) }
	public static func add(state: AdComm.Saves.AwardState, _ fbb: FlatBufferBuilder) { fbb.add(element: state.rawValue, def: 0, at: 1) }
	public static func add(progress: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: progress, def: 0.0, at: 2) }
	public static func endMission(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Experiment: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsExperiment(bb: ByteBuffer) -> Experiment { return Experiment(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: UInt32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public var rewardCount: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var timeRemaining: Double { let o = _accessor.offset(8); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public static func startExperiment(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: id, def: 0, at: 0) }
	public static func add(rewardCount: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: rewardCount, def: 0, at: 1) }
	public static func add(timeRemaining: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: timeRemaining, def: 0.0, at: 2) }
	public static func endExperiment(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Researcher: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsResearcher(bb: ByteBuffer) -> Researcher { return Researcher(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: UInt32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public var level: Int8 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
	public var quantity: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var isNewCard: Bool { let o = _accessor.offset(10); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public static func startResearcher(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
	public static func add(id: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: id, def: 0, at: 0) }
	public static func add(level: Int8, _ fbb: FlatBufferBuilder) { fbb.add(element: level, def: 0, at: 1) }
	public static func add(quantity: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: quantity, def: 0, at: 2) }
	public static func add(isNewCard: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: isNewCard, def: false, at: 3) }
	public static func endResearcher(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct TradeLevel: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsTradeLevel(bb: ByteBuffer) -> TradeLevel { return TradeLevel(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var value: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public static func startTradeLevel(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(value: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: value, def: 0, at: 1) }
	public static func endTradeLevel(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Ad: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsAd(bb: ByteBuffer) -> Ad { return Ad(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var currentViews: Int8 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
	public var viewsToLimit: Int8 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
	public var timeRemaining: Double { let o = _accessor.offset(10); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public static func startAd(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
	public static func add(id: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: id, def: 0, at: 0) }
	public static func add(currentViews: Int8, _ fbb: FlatBufferBuilder) { fbb.add(element: currentViews, def: 0, at: 1) }
	public static func add(viewsToLimit: Int8, _ fbb: FlatBufferBuilder) { fbb.add(element: viewsToLimit, def: 0, at: 2) }
	public static func add(timeRemaining: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: timeRemaining, def: 0.0, at: 3) }
	public static func endAd(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Statistic: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsStatistic(bb: ByteBuffer) -> Statistic { return Statistic(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var value: Double { let o = _accessor.offset(6); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public static func startStatistic(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(value: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: value, def: 0.0, at: 1) }
	public static func endStatistic(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Flag: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsFlag(bb: ByteBuffer) -> Flag { return Flag(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var value: Int8 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
	public static func startFlag(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(value: Int8, _ fbb: FlatBufferBuilder) { fbb.add(element: value, def: 0, at: 1) }
	public static func endFlag(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct StorePromo: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsStorePromo(bb: ByteBuffer) -> StorePromo { return StorePromo(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var expiry: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var viewedTakeover: Bool { let o = _accessor.offset(8); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var offerType: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public static func startStorePromo(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(expiry: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: expiry, def: 0, at: 1) }
	public static func add(viewedTakeover: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: viewedTakeover, def: false, at: 2) }
	public static func add(offerType: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: offerType, def: 0, at: 3) }
	public static func endStorePromo(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct DailyDeals: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsDailyDeals(bb: ByteBuffer) -> DailyDeals { return DailyDeals(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var dealsCount: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func deals(at index: Int32) -> AdComm.Saves.Deal? { let o = _accessor.offset(4); return o == 0 ? nil : AdComm.Saves.Deal(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var expiry: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public static func startDailyDeals(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func addVectorOf(deals: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: deals, at: 0)  }
	public static func add(expiry: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: expiry, def: 0, at: 1) }
	public static func endDailyDeals(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct Deal: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsDeal(bb: ByteBuffer) -> Deal { return Deal(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var type: AdComm.Saves.DealType { let o = _accessor.offset(4); return o == 0 ? AdComm.Saves.DealType.researcher : AdComm.Saves.DealType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.DealType.researcher }
	public var id: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var purchased: Bool { let o = _accessor.offset(8); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var quantity: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var cappedQuantity: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var overCountScienceGain: Int32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var currency: String? { let o = _accessor.offset(16); return o == 0 ? nil : _accessor.string(at: o) }
	public var currencySegmentArray: [UInt8]? { return _accessor.getVector(at: 16) }
	public static func startDeal(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
	public static func add(type: AdComm.Saves.DealType, _ fbb: FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: 0) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 1)  }
	public static func add(purchased: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: purchased, def: false, at: 2) }
	public static func add(quantity: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: quantity, def: 0, at: 3) }
	public static func add(cappedQuantity: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: cappedQuantity, def: 0, at: 4) }
	public static func add(overCountScienceGain: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: overCountScienceGain, def: 0, at: 5) }
	public static func add(currency: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: currency, at: 6)  }
	public static func endDeal(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct GachaScript: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsGachaScript(bb: ByteBuffer) -> GachaScript { return GachaScript(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var gachaId: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var gachaIdSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var lastScriptId: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public static func startGachaScript(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(gachaId: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: gachaId, at: 0)  }
	public static func add(lastScriptId: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: lastScriptId, def: 0, at: 1) }
	public static func endGachaScript(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct AirDropServiceProgress: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsAirDropServiceProgress(bb: ByteBuffer) -> AirDropServiceProgress { return AirDropServiceProgress(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var nextAdResetData: Int64 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var nextClaimCountResetData: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var nextAirDropDate: Int64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var claimCount: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var airDropProgressCount: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func airDropProgress(at index: Int32) -> AdComm.Saves.AirDropModelProgress? { let o = _accessor.offset(12); return o == 0 ? nil : AdComm.Saves.AirDropModelProgress(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startAirDropServiceProgress(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
	public static func add(nextAdResetData: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: nextAdResetData, def: 0, at: 0) }
	public static func add(nextClaimCountResetData: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: nextClaimCountResetData, def: 0, at: 1) }
	public static func add(nextAirDropDate: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: nextAirDropDate, def: 0, at: 2) }
	public static func add(claimCount: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: claimCount, def: 0, at: 3) }
	public static func addVectorOf(airDropProgress: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: airDropProgress, at: 4)  }
	public static func endAirDropServiceProgress(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct AirDropModelProgress: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsAirDropModelProgress(bb: ByteBuffer) -> AirDropModelProgress { return AirDropModelProgress(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var airDropWatchCountId: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var airDropWatchCount: Int8 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
	public static func startAirDropModelProgress(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(airDropWatchCountId: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: airDropWatchCountId, def: 0, at: 0) }
	public static func add(airDropWatchCount: Int8, _ fbb: FlatBufferBuilder) { fbb.add(element: airDropWatchCount, def: 0, at: 1) }
	public static func endAirDropModelProgress(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct OfferTypeToPromoExpiry: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsOfferTypeToPromoExpiry(bb: ByteBuffer) -> OfferTypeToPromoExpiry { return OfferTypeToPromoExpiry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var offerType: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var expiry: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public static func startOfferTypeToPromoExpiry(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(offerType: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: offerType, def: 0, at: 0) }
	public static func add(expiry: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: expiry, def: 0, at: 1) }
	public static func endOfferTypeToPromoExpiry(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct PendingLeaderboardScore: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsPendingLeaderboardScore(bb: ByteBuffer) -> PendingLeaderboardScore { return PendingLeaderboardScore(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var score: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var isCheater: Bool { let o = _accessor.offset(6); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public static func startPendingLeaderboardScore(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(score: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: score, def: 0, at: 0) }
	public static func add(isCheater: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: isCheater, def: false, at: 1) }
	public static func endPendingLeaderboardScore(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct OfferPoolSaveData: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsOfferPoolSaveData(bb: ByteBuffer) -> OfferPoolSaveData { return OfferPoolSaveData(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var segmentId: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var segmentIdSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var offerType: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var index: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public static func startOfferPoolSaveData(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(segmentId: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: segmentId, at: 0)  }
	public static func add(offerType: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: offerType, def: 0, at: 1) }
	public static func add(index: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: index, def: 0, at: 2) }
	public static func endOfferPoolSaveData(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct OfferResetData: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsOfferResetData(bb: ByteBuffer) -> OfferResetData { return OfferResetData(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var offerType: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var expiry: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var rank: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public static func startOfferResetData(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(offerType: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: offerType, def: 0, at: 0) }
	public static func add(expiry: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: expiry, def: 0, at: 1) }
	public static func add(rank: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: rank, def: 0, at: 2) }
	public static func endOfferResetData(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct OfferData: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsOfferData(bb: ByteBuffer) -> OfferData { return OfferData(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var expiry: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var viewedTakeover: Bool { let o = _accessor.offset(8); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var offerType: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var displayName: String? { let o = _accessor.offset(12); return o == 0 ? nil : _accessor.string(at: o) }
	public var displayNameSegmentArray: [UInt8]? { return _accessor.getVector(at: 12) }
	public static func startOfferData(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(expiry: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: expiry, def: 0, at: 1) }
	public static func add(viewedTakeover: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: viewedTakeover, def: false, at: 2) }
	public static func add(offerType: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: offerType, def: 0, at: 3) }
	public static func add(displayName: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: displayName, at: 4)  }
	public static func endOfferData(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct SaveGameModel: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsSaveGameModel(bb: ByteBuffer) -> SaveGameModel { return SaveGameModel(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var dataVersion: UInt16 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
	public var saveVersion: UInt32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public var saveTime: Int64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var resourcesCount: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func resources(at index: Int32) -> AdComm.Saves.Resource? { let o = _accessor.offset(10); return o == 0 ? nil : AdComm.Saves.Resource(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var industriesCount: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func industries(at index: Int32) -> AdComm.Saves.Industry? { let o = _accessor.offset(12); return o == 0 ? nil : AdComm.Saves.Industry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var generatorsCount: Int32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func generators(at index: Int32) -> AdComm.Saves.Generator? { let o = _accessor.offset(14); return o == 0 ? nil : AdComm.Saves.Generator(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var missionsCount: Int32 { let o = _accessor.offset(16); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func missions(at index: Int32) -> AdComm.Saves.Mission? { let o = _accessor.offset(16); return o == 0 ? nil : AdComm.Saves.Mission(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var experimentsCount: Int32 { let o = _accessor.offset(18); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func experiments(at index: Int32) -> AdComm.Saves.Experiment? { let o = _accessor.offset(18); return o == 0 ? nil : AdComm.Saves.Experiment(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var researchersCount: Int32 { let o = _accessor.offset(20); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func researchers(at index: Int32) -> AdComm.Saves.Researcher? { let o = _accessor.offset(20); return o == 0 ? nil : AdComm.Saves.Researcher(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var tradeLevelsCount: Int32 { let o = _accessor.offset(22); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func tradeLevels(at index: Int32) -> AdComm.Saves.TradeLevel? { let o = _accessor.offset(22); return o == 0 ? nil : AdComm.Saves.TradeLevel(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var gachaScriptsCount: Int32 { let o = _accessor.offset(24); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func gachaScripts(at index: Int32) -> AdComm.Saves.GachaScript? { let o = _accessor.offset(24); return o == 0 ? nil : AdComm.Saves.GachaScript(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var storePromosCount: Int32 { let o = _accessor.offset(26); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func storePromos(at index: Int32) -> AdComm.Saves.StorePromo? { let o = _accessor.offset(26); return o == 0 ? nil : AdComm.Saves.StorePromo(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var adsCount: Int32 { let o = _accessor.offset(28); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func ads(at index: Int32) -> AdComm.Saves.Ad? { let o = _accessor.offset(28); return o == 0 ? nil : AdComm.Saves.Ad(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var flagsCount: Int32 { let o = _accessor.offset(30); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func flags(at index: Int32) -> AdComm.Saves.Flag? { let o = _accessor.offset(30); return o == 0 ? nil : AdComm.Saves.Flag(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var statisticsCount: Int32 { let o = _accessor.offset(32); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func statistics(at index: Int32) -> AdComm.Saves.Statistic? { let o = _accessor.offset(32); return o == 0 ? nil : AdComm.Saves.Statistic(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var tutorialsCount: Int32 { let o = _accessor.offset(34); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func tutorials(at index: Int32) -> String? { let o = _accessor.offset(34); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var tutorialCheckpoint: String? { let o = _accessor.offset(36); return o == 0 ? nil : _accessor.string(at: o) }
	public var tutorialCheckpointSegmentArray: [UInt8]? { return _accessor.getVector(at: 36) }
	public var dailyDeals: AdComm.Saves.DailyDeals? { let o = _accessor.offset(38); return o == 0 ? nil : AdComm.Saves.DailyDeals(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var rank: Int32 { let o = _accessor.offset(40); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var viewedNewsTime: Int64 { let o = _accessor.offset(42); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var buyModifierIndex: Int32 { let o = _accessor.offset(44); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var specialOfferBadgeResetTime: Int64 { let o = _accessor.offset(46); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var mostRecentWeekendOfferExpiry: Int64 { let o = _accessor.offset(48); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var gender: AdComm.Saves.Gender { let o = _accessor.offset(50); return o == 0 ? AdComm.Saves.Gender.male : AdComm.Saves.Gender(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.Gender.male }
	public var airDropServiceProgress: AdComm.Saves.AirDropServiceProgress? { let o = _accessor.offset(52); return o == 0 ? nil : AdComm.Saves.AirDropServiceProgress(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var lteId: String? { let o = _accessor.offset(54); return o == 0 ? nil : _accessor.string(at: o) }
	public var lteIdSegmentArray: [UInt8]? { return _accessor.getVector(at: 54) }
	public var offerTypeToPromoExpiryCount: Int32 { let o = _accessor.offset(56); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func offerTypeToPromoExpiry(at index: Int32) -> AdComm.Saves.OfferTypeToPromoExpiry? { let o = _accessor.offset(56); return o == 0 ? nil : AdComm.Saves.OfferTypeToPromoExpiry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var previousLoadTime: Int64 { let o = _accessor.offset(58); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var pendingLeaderboardScore: AdComm.Saves.PendingLeaderboardScore? { let o = _accessor.offset(60); return o == 0 ? nil : AdComm.Saves.PendingLeaderboardScore(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var availableFreeGachaCapsules: Int32 { let o = _accessor.offset(62); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var nextFreeGachaTimeRemaining: Double { let o = _accessor.offset(64); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public var lastEarnedSupremeId: String? { let o = _accessor.offset(66); return o == 0 ? nil : _accessor.string(at: o) }
	public var lastEarnedSupremeIdSegmentArray: [UInt8]? { return _accessor.getVector(at: 66) }
	public var previousBracketPlacementIndex: Int32 { let o = _accessor.offset(68); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var offerPoolIndicesCount: Int32 { let o = _accessor.offset(70); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func offerPoolIndices(at index: Int32) -> AdComm.Saves.OfferPoolSaveData? { let o = _accessor.offset(70); return o == 0 ? nil : AdComm.Saves.OfferPoolSaveData(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var offerResetDataCount: Int32 { let o = _accessor.offset(72); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func offerResetData(at index: Int32) -> AdComm.Saves.OfferResetData? { let o = _accessor.offset(72); return o == 0 ? nil : AdComm.Saves.OfferResetData(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var storeOffersCount: Int32 { let o = _accessor.offset(74); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func storeOffers(at index: Int32) -> AdComm.Saves.OfferData? { let o = _accessor.offset(74); return o == 0 ? nil : AdComm.Saves.OfferData(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startSaveGameModel(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 36) }
	public static func add(dataVersion: UInt16, _ fbb: FlatBufferBuilder) { fbb.add(element: dataVersion, def: 0, at: 0) }
	public static func add(saveVersion: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: saveVersion, def: 0, at: 1) }
	public static func add(saveTime: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: saveTime, def: 0, at: 2) }
	public static func addVectorOf(resources: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: resources, at: 3)  }
	public static func addVectorOf(industries: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: industries, at: 4)  }
	public static func addVectorOf(generators: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: generators, at: 5)  }
	public static func addVectorOf(missions: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: missions, at: 6)  }
	public static func addVectorOf(experiments: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: experiments, at: 7)  }
	public static func addVectorOf(researchers: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: researchers, at: 8)  }
	public static func addVectorOf(tradeLevels: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: tradeLevels, at: 9)  }
	public static func addVectorOf(gachaScripts: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: gachaScripts, at: 10)  }
	public static func addVectorOf(storePromos: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: storePromos, at: 11)  }
	public static func addVectorOf(ads: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: ads, at: 12)  }
	public static func addVectorOf(flags: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: flags, at: 13)  }
	public static func addVectorOf(statistics: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: statistics, at: 14)  }
	public static func addVectorOf(tutorials: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: tutorials, at: 15)  }
	public static func add(tutorialCheckpoint: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: tutorialCheckpoint, at: 16)  }
	public static func add(dailyDeals: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: dailyDeals, at: 17)  }
	public static func add(rank: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: rank, def: 0, at: 18) }
	public static func add(viewedNewsTime: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: viewedNewsTime, def: 0, at: 19) }
	public static func add(buyModifierIndex: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: buyModifierIndex, def: 0, at: 20) }
	public static func add(specialOfferBadgeResetTime: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: specialOfferBadgeResetTime, def: 0, at: 21) }
	public static func add(mostRecentWeekendOfferExpiry: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: mostRecentWeekendOfferExpiry, def: 0, at: 22) }
	public static func add(gender: AdComm.Saves.Gender, _ fbb: FlatBufferBuilder) { fbb.add(element: gender.rawValue, def: 0, at: 23) }
	public static func add(airDropServiceProgress: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: airDropServiceProgress, at: 24)  }
	public static func add(lteId: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: lteId, at: 25)  }
	public static func addVectorOf(offerTypeToPromoExpiry: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: offerTypeToPromoExpiry, at: 26)  }
	public static func add(previousLoadTime: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: previousLoadTime, def: 0, at: 27) }
	public static func add(pendingLeaderboardScore: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: pendingLeaderboardScore, at: 28)  }
	public static func add(availableFreeGachaCapsules: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: availableFreeGachaCapsules, def: 0, at: 29) }
	public static func add(nextFreeGachaTimeRemaining: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: nextFreeGachaTimeRemaining, def: 0.0, at: 30) }
	public static func add(lastEarnedSupremeId: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: lastEarnedSupremeId, at: 31)  }
	public static func add(previousBracketPlacementIndex: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: previousBracketPlacementIndex, def: 0, at: 32) }
	public static func addVectorOf(offerPoolIndices: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: offerPoolIndices, at: 33)  }
	public static func addVectorOf(offerResetData: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: offerResetData, at: 34)  }
	public static func addVectorOf(storeOffers: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: storeOffers, at: 35)  }
	public static func endSaveGameModel(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct LteProgress: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsLteProgress(bb: ByteBuffer) -> LteProgress { return LteProgress(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var rank: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public var claimed: Bool { let o = _accessor.offset(8); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public static func startLteProgress(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(rank: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: rank, def: 0, at: 1) }
	public static func add(claimed: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: claimed, def: false, at: 2) }
	public static func endLteProgress(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct PurchaseHistoryData: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsPurchaseHistoryData(bb: ByteBuffer) -> PurchaseHistoryData { return PurchaseHistoryData(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var isLte: Bool { let o = _accessor.offset(4); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var value: Double { let o = _accessor.offset(6); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public var purchaseDate: Int64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var currency: String? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.string(at: o) }
	public var currencySegmentArray: [UInt8]? { return _accessor.getVector(at: 10) }
	public static func startPurchaseHistoryData(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
	public static func add(isLte: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: isLte, def: false, at: 0) }
	public static func add(value: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: value, def: 0.0, at: 1) }
	public static func add(purchaseDate: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: purchaseDate, def: 0, at: 2) }
	public static func add(currency: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: currency, at: 3)  }
	public static func endPurchaseHistoryData(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

public struct SharedSaveGameModel: FlatBufferObject {
	private var _accessor: Table
	public static func getRootAsSharedSaveGameModel(bb: ByteBuffer) -> SharedSaveGameModel { return SharedSaveGameModel(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var dataVersion: UInt16 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
	public var saveVersion: UInt32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public var saveTime: Int64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public var gold: UInt32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public var lteProgressCount: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func lteProgress(at index: Int32) -> AdComm.Saves.LteProgress? { let o = _accessor.offset(12); return o == 0 ? nil : AdComm.Saves.LteProgress(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var lteLearned: Bool { let o = _accessor.offset(14); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var sharedStatisticsCount: Int32 { let o = _accessor.offset(16); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func sharedStatistics(at index: Int32) -> AdComm.Saves.Statistic? { let o = _accessor.offset(16); return o == 0 ? nil : AdComm.Saves.Statistic(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var sharedResourcesCount: Int32 { let o = _accessor.offset(18); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func sharedResources(at index: Int32) -> AdComm.Saves.Resource? { let o = _accessor.offset(18); return o == 0 ? nil : AdComm.Saves.Resource(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var timeHackInventoryLearned: Bool { let o = _accessor.offset(20); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var abTestGroupsCount: Int32 { let o = _accessor.offset(22); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func abTestGroups(at index: Int32) -> String? { let o = _accessor.offset(22); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var sharedGender: AdComm.Saves.Gender { let o = _accessor.offset(24); return o == 0 ? AdComm.Saves.Gender.male : AdComm.Saves.Gender(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? AdComm.Saves.Gender.male }
	public var purchaseHistoryCount: Int32 { let o = _accessor.offset(26); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func purchaseHistory(at index: Int32) -> AdComm.Saves.PurchaseHistoryData? { let o = _accessor.offset(26); return o == 0 ? nil : AdComm.Saves.PurchaseHistoryData(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startSharedSaveGameModel(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
	public static func add(dataVersion: UInt16, _ fbb: FlatBufferBuilder) { fbb.add(element: dataVersion, def: 0, at: 0) }
	public static func add(saveVersion: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: saveVersion, def: 0, at: 1) }
	public static func add(saveTime: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: saveTime, def: 0, at: 2) }
	public static func add(gold: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: gold, def: 0, at: 3) }
	public static func addVectorOf(lteProgress: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: lteProgress, at: 4)  }
	public static func add(lteLearned: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: lteLearned, def: false, at: 5) }
	public static func addVectorOf(sharedStatistics: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: sharedStatistics, at: 6)  }
	public static func addVectorOf(sharedResources: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: sharedResources, at: 7)  }
	public static func add(timeHackInventoryLearned: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: timeHackInventoryLearned, def: false, at: 8) }
	public static func addVectorOf(abTestGroups: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: abTestGroups, at: 9)  }
	public static func add(sharedGender: AdComm.Saves.Gender, _ fbb: FlatBufferBuilder) { fbb.add(element: sharedGender.rawValue, def: 0, at: 10) }
	public static func addVectorOf(purchaseHistory: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: purchaseHistory, at: 11)  }
	public static func endSharedSaveGameModel(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
}

}

// MARK: - Saves

}

// MARK: - AdComm


